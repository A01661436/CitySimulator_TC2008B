import mesa
from mesa import Agent, Model
from mesa.space import MultiGrid
from mesa.time import RandomActivation
import random
from mesa.visualization.modules import CanvasGrid, ChartModule
from mesa.visualization.ModularVisualization import ModularServer
import heapq
import seaborn as sns
import matplotlib.pyplot as plt

# Defining the agents
class Building(Agent):
  def __init__(self, unique_id, model):
      super().__init__(unique_id, model)

class Parking(Agent):
  def __init__(self, unique_id, model):
      super().__init__(unique_id, model)
      self.occupied = False

class Restaurante(Agent):
  def __init__(self, unique_id, model):
      super().__init__(unique_id, model)
      self.occupied = False

class Roundabout(Agent):
  def __init__(self, unique_id, model):
      super().__init__(unique_id, model)

class TrafficLightAgent(Agent):
    def __init__(self, unique_id, model, position, orientation, green_offset):
        super().__init__(unique_id, model)
        self.pos = position
        self.orientation = orientation
        self.state = 'red'  # Estado inicial
        self.green_offset = green_offset

    def change_state(self, new_state):
        self.state = new_state
    
    def detect_emergency_vehicle(self, view_distance):
        direction = self.orientation
        for i in range(1, view_distance + 1):
            # Calcula la próxima celda en la dirección deseada
            if direction == 'norte':
                check_pos = (self.pos[0], self.pos[1] - i)
            elif direction == 'sur':
                check_pos = (self.pos[0], self.pos[1] + i)
            elif direction == 'este':
                check_pos = (self.pos[0] + i, self.pos[1])
            elif direction == 'oeste':
                check_pos = (self.pos[0] - i, self.pos[1])

            # Verifica que la posición esté dentro de los límites del grid
            if (0 <= check_pos[0] < self.model.grid.width) and (0 <= check_pos[1] < self.model.grid.height):
                cell_contents = self.model.grid.get_cell_list_contents(check_pos)
                for agent in cell_contents:
                    if isinstance(agent, EmergencyVehicle):
                        return True
        return False

    def step(self):
        if self.detect_emergency_vehicle(view_distance=3):  # número de celdas a 'ver'
            self.change_state('green')  # Cambia a verde para emergencia
        else:
            pass

class IntersectionController(Agent):
    def __init__(self, unique_id, model, cycle_time=30):
        super().__init__(unique_id, model)
        self.traffic_lights = []  # Lista para almacenar referencias a los semáforos
        self.cycle_time = cycle_time  # Duración del ciclo completo del semáforo
        self.green_duration = 10  # Duración de la luz verde
        self.yellow_duration = 5  # Duración de la luz amarilla
        self.red_duration = 15  # Duración de la luz roja
        self.current_cycle = 0
    
    def calculate_light_state(self, light):
        # Asumiendo que cada semáforo tiene un 'offset' para su tiempo de verde
        if self.current_cycle >= light.green_offset and self.current_cycle < light.green_offset + self.green_duration:
            return 'green'
        elif self.current_cycle >= light.green_offset + self.green_duration and self.current_cycle < light.green_offset + self.green_duration + self.yellow_duration:
            return 'yellow'
        else:
            return 'red'
    
    def step(self):
        self.current_cycle = (self.current_cycle + 1) % self.cycle_time
        for light in self.traffic_lights:
            new_state = self.calculate_light_state(light)
            light.change_state(new_state)

class Car(Agent):
   def __init__(self, unique_id, model, start_parking):
        super().__init__(unique_id, model)
        self.pos = start_parking.pos
        self.start_parking = start_parking
        self.destination_parking = self.find_unique_parking()
        self.path = []
        self.steps_taken = 0
        self.has_arrived = False
        self.crashed = False

        if self.destination_parking:
            self.path = self.calculate_path(self.pos, self.destination_parking.pos)

   def is_cell_blocked(self, pos):
        cell_contents = self.model.grid.get_cell_list_contents(pos)
        return any(isinstance(obj, Car) and obj.crashed for obj in cell_contents)

   def calculate_path(self, start, goal):
        frontier = []
        heapq.heappush(frontier, (0, start))
        came_from = {}
        cost_so_far = {}
        came_from[start] = None
        cost_so_far[start] = 0

        while frontier:
            current = heapq.heappop(frontier)[1]

            if current == goal:
                break

            for next in self.model.allowed_connections.get(current, []):
                if self.is_cell_blocked(next):
                    continue  # Ignorar las celdas bloqueadas

                new_cost = cost_so_far[current] + 1
                if next not in cost_so_far or new_cost < cost_so_far[next]:
                    cost_so_far[next] = new_cost
                    priority = new_cost + self.heuristic(goal, next)
                    heapq.heappush(frontier, (priority, next))
                    came_from[next] = current

        path = []
        current = goal
        while current is not None:
            path.append(current)
            current = came_from.get(current)
        path.reverse()

        if len(path) == 1:  # Solo contiene la posición inicial
            return []

        return path[1:]

   def heuristic(self, a, b):
       return abs(a[0] - b[0]) + abs(a[1] - b[1])

   def find_unique_parking(self):
    # Filtrar solo los estacionamientos que no están ocupados
    available_parkings = [p for p in self.model.parking_agents if not p.occupied and p not in self.model.assigned_parkings and p != self.start_parking]
    if available_parkings:
        chosen_parking = self.random.choice(available_parkings)
        self.model.assigned_parkings.add(chosen_parking)
        return chosen_parking
    else:
        return None
    
   def recalculate_path(self):
        # Asumiendo que self.destination_parking ya está establecido al estacionamiento original asignado al principio
        if self.destination_parking:
            self.path = self.calculate_path(self.pos, self.destination_parking.pos)
        else:
            print(f"Coche {self.unique_id} no tiene un estacionamiento asignado para recalcular la ruta.")

   def check_for_crashes(self):
    cell_contents = self.model.grid.get_cell_list_contents(self.pos)
    cars_in_cell = [obj for obj in cell_contents if isinstance(obj, (Car, Moto))]
    if len(cars_in_cell) > 1:
        for car in cars_in_cell:
            car.crashed = True
        print(f"Choque detectado en {self.pos} involucrando {len(cars_in_cell)} vehículos (Car y Moto).")

   def move(self):
        if self.crashed:
            return

        if self.path:
            next_step = self.path[0]

            if self.model.is_red_light(next_step):
                return  # Semáforo en rojo

            # Verificar choques en la siguiente celda
            cell_contents = self.model.grid.get_cell_list_contents(next_step)
            crash_here = any(isinstance(obj, Car) and obj.crashed for obj in cell_contents)
            if crash_here:
                print(f"Coche {self.unique_id} detectó un choque en {next_step}.")
                self.recalculate_path()
                return

            # Si no hay semáforo en rojo o choque, mover el coche
            self.model.grid.move_agent(self, next_step)
            self.path.pop(0)
            self.steps_taken += 1

            self.check_for_crashes()

   def step(self):
        if self.crashed or self.has_arrived or not self.destination_parking:
            return

        if not self.path:
            self.path = self.calculate_path(self.pos, self.destination_parking.pos)
            if not self.path:
                self.destination_parking = self.find_unique_parking()
                if self.destination_parking:
                    self.path = self.calculate_path(self.pos, self.destination_parking.pos)
                return

        # Intenta mover el coche siguiendo su camino (la lógica de semáforos está en 'move')
        self.move()

class Moto(Agent):
    def __init__(self, unique_id, model, start_restaurante, speed):
        super().__init__(unique_id, model)
        self.pos = start_restaurante.pos
        self.start_restaurante = start_restaurante
        self.destination_restaurante = self.find_unique_restaurante()
        self.path = []
        self.steps_taken = 0
        self.has_arrived = False
        self.crashed = False
        self.speed = speed

        if self.destination_restaurante:
            self.path = self.calculate_path(self.pos, self.destination_restaurante.pos)

    def find_unique_restaurante(self):
        available_restaurantes = [r for r in self.model.restaurante_agents if not r.occupied and r not in self.model.assigned_restaurantes and r != self.start_restaurante]
        if available_restaurantes:
            chosen_restaurante = self.random.choice(available_restaurantes)
            self.model.assigned_restaurantes.add(chosen_restaurante)
            return chosen_restaurante
        else:
            return None

    def calculate_path(self, start, goal):
        frontier = []
        heapq.heappush(frontier, (0, start))
        came_from = {}
        cost_so_far = {}
        came_from[start] = None
        cost_so_far[start] = 0

        while frontier:
            current = heapq.heappop(frontier)[1]

            if current == goal:
                break

            for next in self.model.allowed_connections.get(current, []):
                if self.is_cell_blocked(next):
                    continue  # Ignorar las celdas bloqueadas

                new_cost = cost_so_far[current] + 1
                if next not in cost_so_far or new_cost < cost_so_far[next]:
                    cost_so_far[next] = new_cost
                    priority = new_cost + self.heuristic(goal, next)
                    heapq.heappush(frontier, (priority, next))
                    came_from[next] = current

        path = []
        current = goal
        while current is not None:
            path.append(current)
            current = came_from.get(current)
        path.reverse()

        if len(path) == 1:  # Solo contiene la posición inicial
            return []

        return path[1:]
    
    def heuristic(self, a, b):
       return abs(a[0] - b[0]) + abs(a[1] - b[1])

    def move(self):
        if self.crashed:
            return

        for _ in range(self.speed):  # Mover más rápido basado en la velocidad
            if not self.path:
                break  # Salir del bucle si el camino está vacío

            next_step = self.path[0]

            if self.model.is_red_light(next_step) or self.is_cell_blocked(next_step):
                self.recalculate_path()  # Llamada a recalcular ruta
                break  # Detener el movimiento si hay un semáforo en rojo o un choque adelante

            self.model.grid.move_agent(self, next_step)
            self.path.pop(0)
            self.steps_taken += 1

            self.check_for_crashes()

    def is_cell_blocked(self, pos):
        cell_contents = self.model.grid.get_cell_list_contents(pos)
        return any(isinstance(obj, Car) and obj.crashed for obj in cell_contents)

    def check_for_crashes(self):
        cell_contents = self.model.grid.get_cell_list_contents(self.pos)
        motos_in_cell = [obj for obj in cell_contents if isinstance(obj, (Car, Moto))]
        if len(motos_in_cell) > 1:
            for moto in motos_in_cell:
                moto.crashed = True
                print(f"Moto {moto.unique_id} cambió su estado a 'crashed' en la posición {self.pos}.")
    
    def recalculate_path(self):
        if self.destination_restaurante:
            self.path = self.calculate_path(self.pos, self.destination_restaurante.pos)
            if not self.path:
                print(f"Moto {self.unique_id} no encuentra un camino alternativo.")
            else:
                print(f"Moto {self.unique_id} ha recalculado su ruta.")
        else:
            print(f"Moto {self.unique_id} no tiene un destino asignado.")

    def step(self):
        # Si la moto ha chocado, no se mueve.
        if self.crashed:
            return

        # Si la moto ya ha llegado a su destino, no necesita hacer nada más.
        if self.has_arrived:
            return

        # Si no hay un camino definido, intenta calcular uno.
        if not self.path:
            self.path = self.calculate_path(self.pos, self.destination_restaurante.pos)
            if not self.path:
                # Si no puede encontrar un camino, busca un nuevo restaurante y calcula un camino hacia él.
                self.destination_restaurante = self.find_unique_restaurante()
                if self.destination_restaurante:
                    self.path = self.calculate_path(self.pos, self.destination_restaurante.pos)
                return

        # Mueve la moto a lo largo del camino.
        self.move()

        # Comprueba si la moto ha llegado a su destino.
        if self.pos == self.destination_restaurante.pos:
            # Si la moto llega a su destino, marca que ha llegado y ocupa el restaurante.
            self.has_arrived = True
            self.destination_restaurante.occupied = True

        # Verificar choques después del movimiento.
        self.check_for_crashes()

class EmergencyVehicle(Agent):
    def __init__(self, unique_id, model, start_position, end_position):
        super().__init__(unique_id, model)
        self.pos = start_position
        self.end_position = end_position
        self.path = self.calculate_path(start_position, end_position)
        self.is_emergency_active = True
    
    def recalculate_path(self):
        self.path = self.calculate_path(self.pos, self.end_position)
        if not self.path:
            print(f"Vehículo de emergencia {self.unique_id} no puede encontrar una ruta.")
        else:
            print(f"Nueva ruta para el vehículo de emergencia {self.unique_id}: {self.path}")
    
    def is_cell_blocked(self, pos):
        # Incluir la detección de otros vehículos de emergencia
        cell_contents = self.model.grid.get_cell_list_contents(pos)
        return any(isinstance(obj, Car) and obj.crashed or isinstance(obj, EmergencyVehicle) for obj in cell_contents)

    def calculate_path(self, start, end):
        # Implementación del algoritmo A* para encontrar la ruta más corta
        frontier = []
        heapq.heappush(frontier, (0, start))
        came_from = {}
        cost_so_far = {}
        came_from[start] = None
        cost_so_far[start] = 0

        while frontier:
            current = heapq.heappop(frontier)[1]

            if current == end:
                break

            for next in self.model.allowed_connections.get(current, []):
                if self.is_cell_blocked(next):
                    continue  # Ignorar las celdas bloqueadas

                new_cost = cost_so_far[current] + 1
                if next not in cost_so_far or new_cost < cost_so_far[next]:
                    cost_so_far[next] = new_cost
                    priority = new_cost + self.heuristic(end, next)
                    heapq.heappush(frontier, (priority, next))
                    came_from[next] = current

        # Reconstruir la ruta
        path = []
        current = end
        while current != start:  # no incluir el punto de inicio en la ruta
            path.append(current)
            current = came_from.get(current)
        path.reverse()  # invertir el orden para que comience en el punto de inicio
        return path

    def heuristic(self, a, b):
        # Heurística para el algoritmo A*: distancia Manhattan
        return abs(a[0] - b[0]) + abs(a[1] - b[1])

    def move(self):
        if self.path:
            next_step = self.path[0]
            next_cell_contents = self.model.grid.get_cell_list_contents(next_step)
            is_occupied = any(isinstance(agent, Car) or isinstance(agent, EmergencyVehicle) for agent in next_cell_contents)

            # Verificar si el próximo paso está bloqueado por un choque
            if self.is_cell_blocked(next_step):
                self.recalculate_path()
                return

            # Verificar si hay un semáforo en rojo o choque
            if is_occupied or self.model.is_red_light_or_crash(next_step):
                return

            # Mover el vehículo a la siguiente celda si está libre y no hay luz roja
            self.model.grid.move_agent(self, next_step)
            self.path.pop(0)

    def step(self):
        self.move()
        if self.pos == self.end_position:
            self.model.schedule.remove(self)
            self.model.grid.remove_agent(self)

# Defining the model
class City(Model):
   def __init__(self, width, height):
       self.grid = MultiGrid(width, height, True)
       self.schedule = RandomActivation(self)
       self.parking_agents = []
       self.current_id = 0
       self.running = True
       self.step_count = 0
       self.assigned_parkings = set()
       self.intersection_controller = IntersectionController("ID_Controller", self)
       self.schedule.add(self.intersection_controller)
       self.crash_sites = set()
       self.restaurante_agents = []  # Inicializa la lista de restaurantes
       self.assigned_restaurantes = set()  # Un conjunto para llevar el control de los restaurantes asignados

       # Inicializar las conexiones permitidas
       self.allowed_connections = {
           # Borde de mapa
           (23, 1): [(23, 0), (22, 1)], 
           (23, 0): [(23, 1), (22, 0)], 
           (22, 1): [(22, 0), (21, 1)], 
           (22, 0): [(22, 1), (21, 0)], 
           (21, 1): [(21, 0), (20, 1)], 
           (21, 0): [(21, 1), (20, 0)], 
           (20, 1): [(20, 0), (19, 1)], 
           (20, 0): [(19, 0), (20, 1)],
            (19, 1): [(19, 0), (18, 1)],
            (19, 0): [(18, 0), (19, 1)],
            (18, 1): [(18, 0), (17, 1), (18, 2)],
            (18, 0): [(17, 0), (18, 1)],
            (17, 1): [(17, 0), (16, 1)],
            (17, 0): [(16, 0), (17, 1)],
            (16, 1): [(16, 0), (15, 1)],
            (16, 0): [(15, 0), (16, 1)],
            (15, 1): [(15, 0), (14, 1)],
            (15, 0): [(14, 0), (15, 1)],
            (14, 1): [(14, 0), (13, 1)],
            (14, 0): [(13, 0), (14, 1)],
            (13, 1): [(13, 0), (12, 1)],
            (13, 0): [(12, 0), (13, 1)],
            (12, 1): [(12, 0), (11, 1), (12, 2)],
            (12, 0): [(11, 0), (12, 1)],
            (11, 1): [(11, 0), (10, 1)],
            (11, 0): [(10, 0), (11, 1)],
            (10, 1): [(10, 0), (9, 1)],
            (10, 0): [(9, 0), (10, 1)],
            (9, 1): [(9, 0), (8, 1)],
            (9, 0): [(8, 0), (9, 1)],
            (8, 1): [(8, 0), (7, 1)],
            (8, 0): [(7, 0), (8, 1)],
            (7, 1): [(7, 0), (6, 1)],
            (7, 0): [(6, 0), (7, 1)],
            (6, 1): [(6, 0), (5, 1), (6, 2)],
            (6, 0): [(5, 0), (6, 1)],
            (5, 1): [(5, 0), (4, 1)],
            (5, 0): [(4, 0), (5, 1)],
            (4, 1): [(4, 0), (3, 1)],
            (4, 0): [(3, 0), (4, 1)],
            (3, 1): [(3, 0), (2, 1)],
            (3, 0): [(2, 0), (3, 1)],
            (2, 1): [(2, 0), (1, 1)],
            (2, 0): [(1, 0), (2, 1)],
            (1, 1): [(1, 0), (0, 1), (1, 2)],
            (1, 0): [(0, 0), (1, 1)],
            (0, 1): [(0, 0), (0, 2), (1, 1)],
            (0, 0): [(0, 1), (1, 0)], 
            (0, 2): [(1, 2), (0, 3)],
            (0, 3): [(1, 3), (0, 4)],
            (0, 4): [(1, 4), (0, 5)],
            (0, 5): [(1, 5), (0, 6)],
            (0, 6): [(1, 6), (0, 7)],
            (0, 7): [(1, 7), (0, 8)],
            (0, 8): [(1, 8), (0, 9)],
            (0, 9): [(1, 9), (0, 10)],
            (0, 10): [(1, 10), (0, 11)],
            (0, 11): [(1, 11), (0, 12)],
            (0, 12): [(1, 12), (0, 13)],
            (0, 13): [(1, 13), (0, 14)],
            (0, 14): [(1, 14), (0, 15)],
            (0, 15): [(1, 15), (0, 16)],
            (0, 16): [(1, 16), (0, 17)],
            (0, 17): [(1, 17), (0, 18)],
            (0, 18): [(1, 18), (0, 19)],
            (0, 19): [(1, 19), (0, 20)],
            (0, 20): [(1, 20), (0, 21)],
            (0, 21): [(1, 21), (0, 22)],
            (0, 22): [(1, 22), (0, 23)],
            (0, 23): [(1, 23), (0, 22)],
            (1, 2): [(0, 2), (1, 3)],
            (1, 3): [(0, 3), (1, 4)],
            (1, 4): [(0, 4), (1, 5)],
            (1, 5): [(0, 5), (1, 6)],
            (1, 6): [(0, 6), (1, 7)],
            (1, 7): [(0, 7), (1, 8)],
            (1, 8): [(0, 8), (1, 9)],
            (1, 9): [(0, 9), (1, 10), (2, 9)],
            (1, 10): [(0, 10), (1, 11), (2, 10)],
            (1, 11): [(0, 11), (1, 12), (2, 11)],
            (1, 12): [(0, 12), (1, 13)],
            (1, 13): [(0, 13), (1, 14)],
            (1, 14): [(0, 14), (1, 15)],
            (1, 15): [(0, 15), (1, 16)],
            (1, 16): [(0, 16), (1, 17)],
            (1, 17): [(0, 17), (1, 18), (2, 17)],
            (1, 18): [(0, 18), (1, 19)],
            (1, 19): [(0, 19), (1, 20)],
            (1, 20): [(0, 20), (1, 21)],
            (1, 21): [(0, 21), (1, 22)],
            (1, 22): [(0, 22), (1, 23), (2, 22)],
            (1, 23): [(1, 22), (2, 23)], 
            (2, 22): [(3, 22), (2, 23)],
            (3, 22): [(4, 22), (3, 23)],
            (4, 22): [(5, 22), (4, 23)],
            (5, 22): [(6, 22), (5, 23), (5, 21)],
            (6, 22): [(7, 22), (6, 23)],
            (7, 22): [(8, 22), (7, 23)],
            (8, 22): [(9, 22), (8, 23)],
            (9, 22): [(10, 22), (9, 23)],
            (10, 22): [(11, 22), (10, 23)],
            (11, 22): [(12, 22), (11, 23), (11, 21)],
            (12, 22): [(13, 22), (12, 23)],
            (13, 22): [(14, 22), (13, 23)],
            (14, 22): [(15, 22), (14, 23), (14, 21)],
            (15, 22): [(16, 22), (15, 23)],
            (16, 22): [(17, 22), (16, 23)],
            (17, 22): [(18, 22), (17, 23), (17, 21)],
            (18, 22): [(19, 22), (18, 23)],
            (19, 22): [(20, 22), (19, 23)],
            (20, 22): [(21, 22), (20, 23)],
            (21, 22): [(22, 22), (21, 23)],
            (22, 22): [(22, 23), (23, 22), (22, 21)],
            (23, 22): [(23, 23), (22, 22), (23, 21)],
            (2, 23): [(3, 23), (2, 22)],
            (3, 23): [(4, 23), (3, 22)],
            (4, 23): [(5, 23), (4, 22)],
            (5, 23): [(6, 23), (5, 22)],
            (6, 23): [(7, 23), (6, 22)],
            (7, 23): [(8, 23), (7, 22)],
            (8, 23): [(9, 23), (8, 22)],
            (9, 23): [(10, 23), (9, 22)],
            (10, 23): [(11, 23), (10, 22)],
            (11, 23): [(12, 23), (11, 22)],
            (12, 23): [(13, 23), (12, 22)],
            (13, 23): [(14, 23), (13, 22)],
            (14, 23): [(15, 23), (14, 22)],
            (15, 23): [(16, 23), (15, 22)],
            (16, 23): [(17, 23), (16, 22)],
            (17, 23): [(18, 23), (17, 22)],
            (18, 23): [(19, 23), (18, 22)],
            (19, 23): [(20, 23), (19, 22)],
            (20, 23): [(21, 23), (20, 22)],
            (21, 23): [(22, 23), (21, 22)],
            (22, 23): [(23, 23), (22, 22)],
            (23, 23): [(23, 22), (22, 23)], 
            (22, 2): [(23, 2), (22, 1)],
            (22, 3): [(23, 3), (22, 2), (21, 3)],
            (22, 4): [(23, 4), (22, 3)],
            (22, 5): [(23, 5), (22, 4)],
            (22, 6): [(23, 6), (22, 5)],
            (22, 7): [(23, 7), (22, 6)],
            (22, 8): [(23, 8), (22, 7)],
            (22, 9): [(23, 9), (22, 8)],
            (22, 10): [(23, 10), (22, 9)],
            (22, 11): [(23, 11), (22, 10)],
            (22, 12): [(23, 12), (22, 11), (21, 12)],
            (22, 13): [(23, 13), (22, 12), (21, 13)],
            (22, 14): [(23, 14), (22, 13), (21, 14)],
            (22, 15): [(23, 15), (22, 14)],
            (22, 16): [(23, 16), (22, 15)],
            (22, 17): [(23, 17), (22, 16)],
            (22, 18): [(23, 18), (22, 17)],
            (22, 19): [(23, 19), (22, 18), (21, 19)],
            (22, 20): [(23, 20), (22, 19)],
            (22, 21): [(23, 21), (22, 20)],
            (23, 2): [(22, 2), (23, 1)],
            (23, 3): [(22, 3), (23, 2)],
            (23, 4): [(22, 4), (23, 3)],
            (23, 5): [(22, 5), (23, 4)],
            (23, 6): [(22, 6), (23, 5)],
            (23, 7): [(22, 7), (23, 6)],
            (23, 8): [(22, 8), (23, 7)],
            (23, 9): [(22, 9), (23, 8)],
            (23, 10): [(22, 10), (23, 9)],
            (23, 11): [(22, 11), (23, 10)],
            (23, 12): [(22, 12), (23, 11)],
            (23, 13): [(22, 13), (23, 12)],
            (23, 14): [(22, 14), (23, 13)],
            (23, 15): [(22, 15), (23, 14)],
            (23, 16): [(22, 16), (23, 15)],
            (23, 17): [(22, 17), (23, 16)],
            (23, 18): [(22, 18), (23, 17)],
            (23, 19): [(22, 19), (23, 18)],
            (23, 20): [(22, 20), (23, 19)],
            (23, 21): [(22, 21), (23, 20)], 



           # Dentro del mapa
           (5, 21): [(5, 20)], 
           (5, 20): [(5, 19)], 
           (5, 19): [(5, 18)], 
           (5, 18): [(5, 17)], 
           (5, 17): [(5, 16)], 
           (5, 16): [(5, 15)], 
           (5, 15): [(5, 14)], 
           (5, 8): [(5, 7)], 
           (5, 7): [(5, 6)], 
           (5, 6): [(5, 5)], 
           (5, 5): [(5, 4)], 
           (5, 4): [(5, 3), (4, 4)], 
           (5, 3): [(5, 2)], 
           (5, 2): [(5, 1)], 
           (6, 2): [(6, 3)], 
           (6, 3): [(6, 4)], 
           (6, 4): [(6, 5)], 
           (6, 5): [(6, 6)], 
           (6, 6): [(6, 7), (7, 6)], 
           (6, 7): [(6, 8)], 
           (6, 8): [(6, 9)], 
           (6, 15): [(6, 16)], 
           (6, 16): [(6, 17)], 
           (6, 17): [(6, 18)], 
           (6, 18): [(6, 19)], 
           (6, 19): [(6, 20), (7, 19)], 
           (6, 20): [(6, 21)], 
           (6, 21): [(6, 22)], 
           (11, 21): [(11, 20)], 
           (11, 20): [(11, 19)], 
           (11, 19): [(11, 18)], 
           (11, 18): [(11, 17)], 
           (11, 17): [(11, 16)], 
           (11, 16): [(11, 15)], 
           (11, 15): [(11, 14)], 
           (11, 8): [(11, 7)], 
           (11, 7): [(11, 6)], 
           (11, 6): [(11, 5)], 
           (11, 5): [(11, 4)], 
           (11, 4): [(11, 3)], 
           (11, 3): [(11, 2)], 
           (11, 2): [(11, 1)], 
           (12, 2): [(12, 3)], 
           (12, 3): [(12, 4)], 
           (12, 4): [(12, 5)], 
           (12, 5): [(12, 6), (13, 5)], 
           (12, 6): [(12, 7)], 
           (12, 7): [(12, 8)], 
           (12, 8): [(12, 9)], 
           (12, 15): [(12, 16)], 
           (12, 16): [(12, 17)], 
           (12, 17): [(12, 18)], 
           (12, 18): [(12, 19)], 
           (12, 19): [(12, 20)], 
           (12, 20): [(12, 21)], 
           (12, 21): [(12, 22)], 
           (17, 21): [(17, 20)], 
           (17, 20): [(17, 19)], 
           (17, 19): [(17, 18)], 
           (17, 18): [(17, 17)], 
           (17, 17): [(17, 16), (16, 17)], 
           (17, 16): [(17, 15)], 
           (17, 15): [(17, 14)], 
           (17, 8): [(17, 7)], 
           (17, 7): [(17, 6), (16, 7)], 
           (17, 6): [(17, 5)], 
           (17, 5): [(17, 4)], 
           (17, 4): [(17, 3)], 
           (17, 3): [(17, 2)], 
           (17, 2): [(17, 1)], 
           (18, 2): [(18, 3)], 
           (18, 3): [(18, 4)], 
           (18, 4): [(18, 5)], 
           (18, 5): [(18, 6)], 
           (18, 6): [(18, 7)], 
           (18, 7): [(18, 8)], 
           (18, 8): [(18, 9)], 
           (18, 15): [(18, 16)], 
           (18, 16): [(18, 17)], 
           (18, 17): [(18, 18)], 
           (18, 18): [(18, 19)], 
           (18, 19): [(18, 20)], 
           (18, 20): [(18, 21)], 
           (18, 21): [(18, 22)], 

           (21, 14): [(20, 14), (21, 13)], 
           (21, 13): [(21, 14), (20, 13), (21, 12)], 
           (21, 12): [(21, 13), (20, 12)], 
           (20, 14): [(19, 14), (20, 13), (20, 15)], 
           (20, 13): [(20, 14), (19, 13), (20, 12)], 
           (20, 12): [(20, 13), (19, 12)], 
           (19, 14): [(18, 14), (19, 13)], 
           (19, 13): [(19, 14), (18, 13)], 
           (19, 12): [(19, 13)], 
           (18, 14): [(18, 15), (17, 14), (18, 13)], 
           (18, 13): [(18, 14), (17, 13)], 
           (17, 14): [(17, 13), (16, 14)], 
           (17, 13): [(17, 14), (16, 13)], 
           (16, 13): [(16, 14), (15, 13), (16, 12)], 
           (16, 14): [(16, 13), (15, 14)], 
           (16, 12): [(15, 12), (16, 11)], 
           (15, 14): [(15, 13), (14, 14)], 
           (15, 13): [(15, 14), (14, 13), (15, 12)], 
           (15, 12): [(15, 13), (14, 12)], 
           (14, 14): [(13, 14), (14 ,13)], 
           (14, 13): [(14, 14), (13, 13), (14, 12)], 
           (14, 12): [(14, 13), (13, 12)], 
           (13, 14): [(12, 14), (13, 13)], 
           (13, 13): [(13, 14), (12, 13)], 
           (13, 12): [(13, 13)], 
           (12, 14): [(12, 15), (11, 14), (12, 13)], 
           (12, 13): [(12, 14), (11, 13)], 
           (11, 14): [(11, 13), (10, 14)], 
           (11, 13): [(11,14), (10, 13)], 
           (10, 14): [(9, 14), (10, 13)], 
           (10, 13): [(10, 14), (9, 13), (10, 12)], 
           (10, 12): [(9, 12), (10, 11)], 
           (9, 14): [(8, 14), (9, 13)], 
           (9, 13): [(9, 14), (8, 13), (9, 12)], 
           (9, 12): [(9, 13), (8, 12)], 
           (8, 14): [(7, 14), (8, 13)], 
           (8, 13): [(8, 14), (7, 13), (8, 12)], 
           (8, 12): [(8, 13), (7, 12)], 
           (7, 14): [(6, 14), (7, 13)], 
           (7, 13): [(7, 14), (6, 13)], 
           (7, 12): [(7, 13)], 
           (6, 14): [(6, 15), (5, 14), (6, 13)], 
           (6, 13): [(6, 14), (5, 13)], 
           (5, 14): [(5, 13), (4, 14)], 
           (5, 13): [(5, 14), (4, 13)], 
           (4, 14): [(4, 13), (3, 14)], 
           (4, 13): [(4, 14), (3, 13), (4, 12)], 
           (4, 12): [(3, 12), (4, 11)], 
           (3, 14): [(2, 14), (3, 13)], 
           (3, 13): [(3, 14), (2, 13), (3, 12)], 
           (3, 12): [(3, 13), (2, 12)], 
           (2, 14): [(1, 14), (2, 13)], 
           (2, 13): [(2, 14), (1, 13), (2, 12)], 
           (2, 12): [(2, 13), (1, 12)], 
           (2, 11): [(3, 11), (2, 10)], 
           (2, 10): [(2, 11), (3, 10), (2, 9)], 
           (2, 9): [(2, 10), (3, 9)], 
           (3, 11): [(4, 11), (3, 10)], 
           (3, 10): [(3, 11), (4, 10), (3, 9)], 
           (3, 9): [(4, 9), (3, 10)], 
           (4, 11): [(4, 10)], 
           (4, 10): [(5, 10), (4, 9)], 
           (4, 9): [(4, 10), (5, 9)], 
           (5, 9): [(5, 10), (6, 9), (5, 8)], 
           (5, 10): [(6, 10), (5, 9)], 
           (6, 10): [(6, 9), (7, 10)],
           (6, 9): [(6, 10), (7, 9)], 
           (7, 11): [(8, 11), (7, 12)], 
           (7, 10): [(7, 11), (8, 10), (7, 9)], 
           (7, 9): [(7, 10), (8, 9)], 
           (8, 11): [(9, 11), (8, 10)], 
           (8, 10): [(8, 11), (9, 10), (8, 9)],
           (8, 9): [(8, 10), (9, 9)], 
           (9, 11): [(10, 11), (9, 10)], 
           (9, 10): [(9, 11), (10, 10), (9, 9)], 
           (9, 9): [(9, 10), (10, 9)], 
           (10, 11): [(10, 10)], 
           (10, 10): [(11, 10), (10, 9)],
           (10, 9): [(10, 10), (11, 9)], 
           (11, 10): [(12, 10), (11, 9)], 
           (11, 9): [(11, 10), (12, 9), (11, 8)], 
           (12, 10): [(13, 10), (12, 9)], 
           (12, 9): [(12, 10), (13, 9)], 
           (13, 9): [(13, 10), (14, 9)],
           (13, 10): [(13, 9), (14, 10), (13, 11)], 
           (13, 11): [(14, 11), (13, 12)], 
           (14, 9): [(14, 10), (15, 9)], 
           (14, 10): [(14, 11), (15, 10), (14, 9)], 
           (14, 11): [(14, 10), (15, 11)], 
           (15, 9): [(16, 9), (15, 10)],
           (15, 10): [(15, 11), (16, 10), (15, 9)], 
           (15, 11): [(16, 11), (15, 10)], 
           (16, 11): [(16, 10)], 
           (16, 10): [(17, 10), (16, 9)], 
           (16, 9): [(16, 10), (17, 9)], 
           (17, 10): [(18, 10), (17, 9)],
           (17, 9): [(17, 10), (18, 9), (17, 8)], 
           (18, 10): [(19, 10), (18, 9)], 
           (18, 9): [(19, 9), (18, 10)], 
           (19, 11): [(20, 11), (19, 12)], 
           (19, 10): [(19, 11), (20, 10), (19, 9)], 
           (19, 9): [(19, 10), (20, 9)],
           (20, 11): [(21, 11), (20, 10)], 
           (20, 10): [(20, 11), (21, 10), (20, 9)], 
           (20, 9): [(20, 10), (21, 9)], 
           (21, 11): [(22, 11), (21, 10)], 
           (21, 10): [(21, 11), (22, 10), (21, 9)], 
           (21, 9): [(21, 10), (22, 9)],

           # Estacionamientos y sus adyacentes
           (2, 17): [(1, 17)], 
           (7, 19): [(6, 19)], 
           (7, 6): [(6, 6)], 
           (13, 5): [(12, 5)], 
           (16, 7): [(17, 7)], 
           (16, 17): [(17, 17)], 
           (21, 19): [(22, 19)], 
           (20, 15): [(20, 14)], 
           (21, 3): [(22, 3)], 

           # Restaurantes y sus adyacentes
           (14, 21): [(14, 22)], 
           (4, 4): [(5, 4)],
       }

       # Validar que todas las conexiones son tuplas
       for key, connections in self.allowed_connections.items():
            for connection in connections:
                if not isinstance(connection, tuple):
                    print(f"Error en la conexión: {key} a {connection}, que no es una tupla.")

       traffic_lights_data = [
            ((0, 21), 'norte'),
            ((1, 21), 'norte'),
            ((4, 23), 'oeste'), 
            ((4, 22), 'oeste'), 
            ((6, 21), 'norte'), 
            ((5, 15), 'sur'), 
            ((10, 23), 'oeste'),
            ((10, 22), 'oeste'), 
            ((11, 15), 'sur'), 
            ((12, 21), 'norte'), 
            ((16, 22), 'oeste'), 
            ((16, 23), 'oeste'),
            ((17, 15), 'sur'),
            ((18, 21), 'norte'), 
            ((21, 23), 'oeste'), 
            ((21, 22), 'oeste'), 
            ((22, 15), 'sur'), 
            ((23, 15), 'sur'), 

            ((0, 8), 'norte'),
            ((1, 8), 'norte'),
            ((2, 1), 'este'), 
            ((2, 0), 'este'), 
            ((5, 2), 'sur'), 
            ((6, 8), 'norte'), 
            ((7, 1), 'este'),
            ((7, 0), 'este'), 
            ((11, 2), 'sur'), 
            ((12, 8), 'norte'), 
            ((13, 1), 'este'), 
            ((13, 0), 'este'),
            ((17, 2), 'sur'),
            ((18, 8), 'norte'), 
            ((19, 1), 'este'), 
            ((19, 0), 'este'), 
            ((22, 2), 'sur'), 
            ((23, 2), 'sur')
        ]

        # Obtiene el número total de semáforos
       num_traffic_lights = len(traffic_lights_data)

        # El tiempo total disponible para offsets es el ciclo menos la duración de la luz verde y amarilla
       available_offset_time = self.intersection_controller.cycle_time - (self.intersection_controller.green_duration + self.intersection_controller.yellow_duration)

        # Divide el tiempo disponible de manera uniforme entre los semáforos
       offset_increment = available_offset_time // num_traffic_lights
       
       for i, (pos, orientation) in enumerate(traffic_lights_data):
        # Asegúrate de que los offsets se distribuyan uniformemente
        green_offset = (i * 5) % self.intersection_controller.cycle_time
        traffic_light = TrafficLightAgent(self.next_id(), self, pos, orientation, green_offset)
        self.grid.place_agent(traffic_light, pos)
        self.schedule.add(traffic_light)
        self.intersection_controller.traffic_lights.append(traffic_light)
        
    
       self.place_buildings(range(2, 5), [21, 20, 19, 18, 16, 15, 8, 7, 6, 5, 3, 2])
       self.place_buildings(range(3, 5), [17])
       self.place_buildings(range(2, 4), [4])
       self.place_buildings(range(7, 11), [21, 20, 18, 17, 16, 15, 8, 7, 5, 4, 3, 2])
       self.place_buildings(range(8, 11), [19, 6])
       self.place_buildings(range(13, 14), [21])
       self.place_buildings(range(15, 17), [21])
       self.place_buildings(range(13, 17), [20, 19, 18, 16, 15, 8, 6, 4, 3, 2])
       self.place_buildings(range(13, 16), [17, 7])
       self.place_buildings(range(14, 17), [5])
       self.place_buildings(range(19, 22), [21, 20, 18, 17, 16, 8, 7, 6, 5, 4, 2])
       self.place_buildings(range(19, 21), [19, 3])
       self.place_buildings(range(19, 20), [15])
       self.place_buildings(range(21, 22), [15])

       self.place_parkings([(2, 17), (7, 19), (7, 6), (16, 17), (13, 5), (16, 7), (21, 19), (20, 15), (21, 3)])
      
       self.place_restaurantes([(14, 21), (4, 4)])
      
       self.place_roundabouts([(5, 12), (6, 12), (5, 11), (6, 11), (11, 12), (11, 11), (12, 12), (12, 11), (17, 12), (17, 11), (18, 12), (18, 11)])

       for restaurante_agent in self.restaurante_agents:
        moto = Moto(self.next_id(), self, restaurante_agent, speed=2)  # Asumiendo velocidad 2 para las motos
        if moto.destination_restaurante:
            self.grid.place_agent(moto, restaurante_agent.pos)
            self.schedule.add(moto)

   # Generar un coche en cada estacionamiento al inicio de la simulación
       for parking_agent in self.parking_agents:
        car = Car(self.next_id(), self, parking_agent)
        if car.destination_parking:
            self.grid.place_agent(car, parking_agent.pos)
            self.schedule.add(car)

   def place_buildings(self, x_range, y_positions):
       for x in x_range:
           for y in y_positions:
               building = Building(self.next_id(), self)
               self.grid.place_agent(building, (x, y))
               self.schedule.add(building)

   def place_parkings(self, positions):
       for x, y in positions:
           parking = Parking(self.next_id(), self)
           self.grid.place_agent(parking, (x, y))
           self.schedule.add(parking)
           self.parking_agents.append(parking)
  
   def place_roundabouts(self, positions):
       for x, y in positions:
           roundabout = Roundabout(self.next_id(), self)
           self.grid.place_agent(roundabout, (x, y))
           self.schedule.add(roundabout)
    
   def place_restaurantes(self, positions):
        for x, y in positions:
            restaurante = Restaurante(self.next_id(), self)
            self.grid.place_agent(restaurante, (x, y))
            self.schedule.add(restaurante)
            self.restaurante_agents.append(restaurante)
    
   def border_positions(self):
        # Retorna una lista de posiciones en el borde del mapa
        border_positions = []
        # Añade las posiciones de los bordes superior e inferior
        for x in range(self.grid.width):
            border_positions.append((x, 0))  # Borde superior
            border_positions.append((x, self.grid.height - 1))  # Borde inferior
        # Añade las posiciones de los bordes izquierdo y derecho
        for y in range(1, self.grid.height - 1):  # Evita las esquinas
            border_positions.append((0, y))  # Borde izquierdo
            border_positions.append((self.grid.width - 1, y))  # Borde derecho
        return border_positions
    
   def add_emergency_vehicle(self):
        start_position, end_position = self.random.sample(self.border_positions(), 2)
        emergency_vehicle = EmergencyVehicle(self.next_id(), self, start_position, end_position)
        self.grid.place_agent(emergency_vehicle, start_position)
        self.schedule.add(emergency_vehicle)

   def next_id(self):
       self.current_id += 1
       return self.current_id
  
   def is_red_light(self, pos):
        cell_contents = self.grid.get_cell_list_contents([pos])
        traffic_lights = [agent for agent in cell_contents if isinstance(agent, TrafficLightAgent)]
        return any(light.state == 'red' for light in traffic_lights)
    
   def is_red_light_or_crash(self, pos):
        cell_contents = self.grid.get_cell_list_contents([pos])
        traffic_lights = [agent for agent in cell_contents if isinstance(agent, TrafficLightAgent)]
        is_red_light = any(light.state == 'red' for light in traffic_lights)

        crashed_cars = [agent for agent in cell_contents if isinstance(agent, Car) and agent.crashed]
        is_crash = len(crashed_cars) > 0

        return is_red_light or is_crash

   def total_steps_taken(self):
        return sum(car.steps_taken for car in self.schedule.agents if isinstance(car, Car) and car.has_arrived)

   def step(self):
       self.schedule.step()
       self.step_count += 1
       if self.step_count >= 1000:
            total_steps = self.total_steps_taken()
            print(f"Total de pasos para que todos los coches lleguen a sus destinos: {total_steps}")
            self.running = False
       if self.random.random() < 0.05:
            self.add_emergency_vehicle()

# Initialize and run the model
city_model = City(24, 24)
while city_model.running:
  city_model.step()

def agent_portrayal(agent):
    if isinstance(agent, Car):
        color = "black" if agent.crashed else "pink"
        portrayal = {"Shape": "circle", "Filled": "true", "Layer": 0, "Color": color, "r": 0.3}
    elif isinstance(agent, Moto):
        color = "black" if agent.crashed else "orange"
        portrayal = {"Shape": "circle", "Filled": "true", "Layer": 0, "Color": color, "r": 0.3}
    elif isinstance(agent, EmergencyVehicle):
        portrayal = {"Shape": "circle", "Filled": "true", "Layer": 0, "Color": "purple", "r": 0.3}
    elif isinstance(agent, Restaurante):
        portrayal = {"Shape": "rect", "Filled": "true", "Layer": 0, "Color": "purple", "w": 1, "h": 1}
    elif isinstance(agent, Parking):
        portrayal = {"Shape": "rect", "Filled": "true", "Layer": 0, "Color": "grey", "w": 1, "h": 1}
    elif isinstance(agent, Roundabout):
        portrayal = {"Shape": "rect", "Filled": "true", "Layer": 0, "Color": "brown", "w": 1, "h": 1}
    elif isinstance(agent, TrafficLightAgent):
        if agent.state == 'red':
            color = "red"
        elif agent.state == 'green':
            color = "green"
        elif agent.state == 'yellow':
            color = "yellow"
        portrayal = {"Shape": "circle", "Filled": "true", "Layer": 0, "Color": color, "r": 0.8}
    elif isinstance(agent, Building):
        portrayal = {"Shape": "rect", "Filled": "true", "Layer": 0, "Color": "blue", "w": 1, "h": 1}
    return portrayal

grid = CanvasGrid(agent_portrayal, 24, 24, 500, 500)

server = ModularServer(City,
                     [grid],  # Include any other modules you've defined
                     "City Simulation",
                     {"width": 24, "height": 24})  # Include any model parameters if necessary


server.port = 8521  # Default is 8521, but you can choose another
server.launch()
