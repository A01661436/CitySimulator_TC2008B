import mesa
import requests
from mesa import Agent, Model
from mesa.space import MultiGrid
from mesa.time import RandomActivation
import random
from mesa.visualization.modules import CanvasGrid, ChartModule
from mesa.visualization.ModularVisualization import ModularServer
import heapq
import seaborn as sns
import matplotlib.pyplot as plt

# Definici√≥n de los Agentes
class Building(Agent):
  def __init__(self, unique_id, model):
      super().__init__(unique_id, model)

class Parking(Agent):
  def __init__(self, unique_id, model):
      super().__init__(unique_id, model)
      self.occupied = False

class Restaurante(Agent):
  def __init__(self, unique_id, model):
      super().__init__(unique_id, model)
      self.occupied = False

class BusStop(Agent):
    def __init__(self, unique_id, model):
        super().__init__(unique_id, model)
        self.occupied = False

class Hospital(Agent):
    def __init__(self, unique_id, model):
        super().__init__(unique_id, model)
        self.occupied = False

class Roundabout(Agent):
  def __init__(self, unique_id, model):
      super().__init__(unique_id, model)

class TrafficLightAgent(Agent):
    def __init__(self, unique_id, model, position, orientation, green_offset):
        super().__init__(unique_id, model)
        self.pos = position
        self.orientation = orientation
        self.state = 'red'
        self.green_offset = green_offset
    
    def detect_emergency_vehicle(self, view_distance):
        direction = self.orientation
        for i in range(1, view_distance + 1):
            if direction == 'norte':
                check_pos = (self.pos[0], self.pos[1] - i)
            elif direction == 'sur':
                check_pos = (self.pos[0], self.pos[1] + i)
            elif direction == 'este':
                check_pos = (self.pos[0] + i, self.pos[1])
            elif direction == 'oeste':
                check_pos = (self.pos[0] - i, self.pos[1])

            if (0 <= check_pos[0] < self.model.grid.width) and (0 <= check_pos[1] < self.model.grid.height):
                cell_contents = self.model.grid.get_cell_list_contents(check_pos)
                for agent in cell_contents:
                    if isinstance(agent, EmergencyVehicle):
                        return True
        return False

    def change_state(self, new_state):
        self.state = new_state

    def step(self):
        if self.detect_emergency_vehicle(view_distance=3):
            self.change_state('green')
        else:
            pass

class Car(Agent):
   def __init__(self, unique_id, model, start_parking):
        super().__init__(unique_id, model)
        self.pos = start_parking.pos
        self.start_parking = start_parking
        self.destination_parking = self.find_unique_parking()
        self.path = []
        self.steps_taken = 0
        self.has_arrived = False
        self.crashed = False

        if self.destination_parking:
            self.path = self.calculate_path(self.pos, self.destination_parking.pos)
    
   def find_unique_parking(self):
        available_parkings = [p for p in self.model.parking_agents if not p.occupied and p not in self.model.assigned_parkings and p != self.start_parking]
        if available_parkings:
            chosen_parking = self.random.choice(available_parkings)
            self.model.assigned_parkings.add(chosen_parking)
            return chosen_parking
        else:
            return None

   def calculate_path(self, start, goal):
        frontier = []
        heapq.heappush(frontier, (0, start))
        came_from = {}
        cost_so_far = {}
        came_from[start] = None
        cost_so_far[start] = 0

        while frontier:
            current = heapq.heappop(frontier)[1]

            if current == goal:
                break

            for next in self.model.allowed_connections.get(current, []):
                if self.is_cell_blocked(next):
                    continue 

                new_cost = cost_so_far[current] + 1
                if next not in cost_so_far or new_cost < cost_so_far[next]:
                    cost_so_far[next] = new_cost
                    priority = new_cost + self.heuristic(goal, next)
                    heapq.heappush(frontier, (priority, next))
                    came_from[next] = current

        path = []
        current = goal
        while current is not None:
            path.append(current)
            current = came_from.get(current)
        path.reverse()

        if len(path) == 1: 
            return []

        return path[1:]

   def heuristic(self, a, b):
       return abs(a[0] - b[0]) + abs(a[1] - b[1])

   def is_cell_blocked(self, pos):
        cell_contents = self.model.grid.get_cell_list_contents(pos)
        return any(isinstance(obj, Car) and obj.crashed for obj in cell_contents)
    
   def recalculate_path(self):
        if self.destination_parking:
            self.path = self.calculate_path(self.pos, self.destination_parking.pos)

   def check_for_crashes(self):
    cell_contents = self.model.grid.get_cell_list_contents(self.pos)
    cars_in_cell = [obj for obj in cell_contents if isinstance(obj, (Car, Moto))]
    if len(cars_in_cell) > 1:
        for car in cars_in_cell:
            car.crashed = True

   def move(self):
        if self.crashed:
            return

        if self.path:
            next_step = self.path[0]

            if self.model.is_red_light(next_step):
                return 

            cell_contents = self.model.grid.get_cell_list_contents(next_step)
            crash_here = any(isinstance(obj, Car) and obj.crashed for obj in cell_contents)
            if crash_here:
                self.recalculate_path()
                return

            self.model.grid.move_agent(self, next_step)
            self.path.pop(0)
            self.steps_taken += 1

            self.check_for_crashes()

   def step(self):
        if self.crashed or self.has_arrived or not self.destination_parking:
            return

        if not self.path:
            self.path = self.calculate_path(self.pos, self.destination_parking.pos)
            if not self.path:
                self.destination_parking = self.find_unique_parking()
                if self.destination_parking:
                    self.path = self.calculate_path(self.pos, self.destination_parking.pos)
                return

        self.move()

class Moto(Agent):
    def __init__(self, unique_id, model, start_restaurante, speed):
        super().__init__(unique_id, model)
        self.pos = start_restaurante.pos
        self.start_restaurante = start_restaurante
        self.destination_restaurante = self.find_unique_restaurante()
        self.path = []
        self.steps_taken = 0
        self.has_arrived = False
        self.crashed = False
        self.speed = speed

        if self.destination_restaurante:
            self.path = self.calculate_path(self.pos, self.destination_restaurante.pos)

    def find_unique_restaurante(self):
        available_restaurantes = [r for r in self.model.restaurante_agents if not r.occupied and r not in self.model.assigned_restaurantes and r != self.start_restaurante]
        if available_restaurantes:
            chosen_restaurante = self.random.choice(available_restaurantes)
            self.model.assigned_restaurantes.add(chosen_restaurante)
            return chosen_restaurante
        else:
            return None

    def calculate_path(self, start, goal):
        frontier = []
        heapq.heappush(frontier, (0, start))
        came_from = {}
        cost_so_far = {}
        came_from[start] = None
        cost_so_far[start] = 0

        while frontier:
            current = heapq.heappop(frontier)[1]

            if current == goal:
                break

            for next in self.model.allowed_connections.get(current, []):
                if self.is_cell_blocked(next):
                    continue

                new_cost = cost_so_far[current] + 1
                if next not in cost_so_far or new_cost < cost_so_far[next]:
                    cost_so_far[next] = new_cost
                    priority = new_cost + self.heuristic(goal, next)
                    heapq.heappush(frontier, (priority, next))
                    came_from[next] = current

        path = []
        current = goal
        while current is not None:
            path.append(current)
            current = came_from.get(current)
        path.reverse()

        if len(path) == 1: 
            return []

        return path[1:]
    
    def heuristic(self, a, b):
       return abs(a[0] - b[0]) + abs(a[1] - b[1])

    def is_cell_blocked(self, pos):
        cell_contents = self.model.grid.get_cell_list_contents(pos)
        return any(isinstance(obj, Car) and obj.crashed for obj in cell_contents)
    
    def recalculate_path(self):
        if self.destination_restaurante:
            self.path = self.calculate_path(self.pos, self.destination_restaurante.pos)

    def check_for_crashes(self):
        cell_contents = self.model.grid.get_cell_list_contents(self.pos)
        motos_in_cell = [obj for obj in cell_contents if isinstance(obj, (Car, Moto))]
        if len(motos_in_cell) > 1:
            for moto in motos_in_cell:
                moto.crashed = True
    
    def move(self):
        if self.crashed:
            return

        for _ in range(self.speed): 
            if not self.path:
                break 

            next_step = self.path[0]

            if self.is_cell_blocked(next_step):
                self.recalculate_path() 
                break 

            self.model.grid.move_agent(self, next_step)
            self.path.pop(0)
            self.steps_taken += 1

            self.check_for_crashes()

    def step(self):
        if self.crashed:
            return

        if self.has_arrived:
            return

        if not self.path:
            self.path = self.calculate_path(self.pos, self.destination_restaurante.pos)
            if not self.path:
                self.destination_restaurante = self.find_unique_restaurante()
                if self.destination_restaurante:
                    self.path = self.calculate_path(self.pos, self.destination_restaurante.pos)
                return

        self.move()

        if self.pos == self.destination_restaurante.pos:
            self.has_arrived = True
            self.destination_restaurante.occupied = True

        self.check_for_crashes()

class Bus(Agent):
    def __init__(self, unique_id, model, start_bus_stop, speed, wait_time = 5):
        super().__init__(unique_id, model)
        self.pos = start_bus_stop.pos
        self.start_bus_stop = start_bus_stop
        self.destination_bus_stop = self.find_unique_bus_stop()
        self.path = []
        self.steps_taken = 0
        self.has_arrived = False
        self.crashed = False
        self.speed = speed
        self.wait_time = wait_time  
        self.wait_counter = 0  

        if self.destination_bus_stop:
            self.path = self.calculate_path(self.pos, self.destination_bus_stop.pos)

    def find_unique_bus_stop(self):
        available_bus_stops = [bs for bs in self.model.bus_stop_agents if not bs.occupied and bs != self.start_bus_stop]
        if available_bus_stops:
            chosen_bus_stop = self.random.choice(available_bus_stops)
            return chosen_bus_stop
        else:
            return None

    def calculate_path(self, start, goal):
        frontier = []
        heapq.heappush(frontier, (0, start))
        came_from = {}
        cost_so_far = {}
        came_from[start] = None
        cost_so_far[start] = 0

        while frontier:
            current = heapq.heappop(frontier)[1]

            if current == goal:
                break

            for next in self.model.allowed_connections.get(current, []):
                if self.is_cell_blocked(next):
                    continue 

                new_cost = cost_so_far[current] + 1
                if next not in cost_so_far or new_cost < cost_so_far[next]:
                    cost_so_far[next] = new_cost
                    priority = new_cost + self.heuristic(goal, next)
                    heapq.heappush(frontier, (priority, next))
                    came_from[next] = current

        path = []
        current = goal
        while current is not None:
            path.append(current)
            current = came_from.get(current)
        path.reverse()

        if len(path) == 1: 
            return []

        return path[1:]

    def heuristic(self, a, b):
        return abs(a[0] - b[0]) + abs(a[1] - b[1])

    def is_cell_blocked(self, pos):
        cell_contents = self.model.grid.get_cell_list_contents(pos)
        return any(isinstance(obj, (Car, Moto, Bus)) and obj.crashed for obj in cell_contents)

    def recalculate_path(self):
        if self.destination_bus_stop:
            self.path = self.calculate_path(self.pos, self.destination_bus_stop.pos)
    
    def check_for_crashes(self):
        cell_contents = self.model.grid.get_cell_list_contents(self.pos)
        vehicles_in_cell = [obj for obj in cell_contents if isinstance(obj, (Car, Moto, Bus))]
        if len(vehicles_in_cell) > 1:
            for vehicle in vehicles_in_cell:
                vehicle.crashed = True
    
    def move(self):
        if self.crashed:
            return

        for _ in range(self.speed): 
            if not self.path:
                break 

            next_step = self.path[0]

            if self.model.is_red_light(next_step) or self.is_cell_blocked(next_step):
                self.recalculate_path() 
                break 

            self.model.grid.move_agent(self, next_step)
            self.path.pop(0)
            self.steps_taken += 1

            self.check_for_crashes()

    def step(self):
        if self.crashed:
            return

        if self.has_arrived:
            if self.wait_counter < self.wait_time:
                self.wait_counter += 1
            else:
                self.wait_counter = 0
                self.has_arrived = False
                self.destination_bus_stop.occupied = False
                self.destination_bus_stop = self.find_unique_bus_stop()
                if self.destination_bus_stop:
                    self.path = self.calculate_path(self.pos, self.destination_bus_stop.pos)

        else:
            if not self.path:
                self.path = self.calculate_path(self.pos, self.destination_bus_stop.pos)
                if not self.path:
                    self.destination_bus_stop = self.find_unique_bus_stop()
                    if self.destination_bus_stop:
                        self.path = self.calculate_path(self.pos, self.destination_bus_stop.pos)
                    return

            self.move()

            if self.pos == self.destination_bus_stop.pos:
                self.has_arrived = True
                self.destination_bus_stop.occupied = True

        self.check_for_crashes()

class EmergencyVehicle(Agent):
    def __init__(self, unique_id, model, start_hospital, speed, wait_time=5):
        super().__init__(unique_id, model)
        self.pos = start_hospital.pos
        self.start_hospital = start_hospital
        self.destination_hospital = self.find_unique_hospital()
        self.path = []
        self.steps_taken = 0
        self.has_arrived = False
        self.crashed = False
        self.speed = speed
        self.wait_time = wait_time
        self.wait_counter = 0

        if self.destination_hospital:
            self.path = self.calculate_path(self.pos, self.destination_hospital.pos)

    def find_unique_hospital(self):
        available_hospitals = [h for h in self.model.hospital_agents if not h.occupied and h != self.start_hospital]
        if available_hospitals:
            chosen_hospital = self.random.choice(available_hospitals)
            return chosen_hospital
        else:
            return None

    def calculate_path(self, start, goal):
        frontier = []
        heapq.heappush(frontier, (0, start))
        came_from = {}
        cost_so_far = {}
        came_from[start] = None
        cost_so_far[start] = 0

        while frontier:
            current = heapq.heappop(frontier)[1]

            if current == goal:
                break

            for next in self.model.allowed_connections.get(current, []):
                if self.is_cell_blocked(next):
                    continue 

                new_cost = cost_so_far[current] + 1
                if next not in cost_so_far or new_cost < cost_so_far[next]:
                    cost_so_far[next] = new_cost
                    priority = new_cost + self.heuristic(goal, next)
                    heapq.heappush(frontier, (priority, next))
                    came_from[next] = current

        path = []
        current = goal
        while current is not None:
            path.append(current)
            current = came_from.get(current)
        path.reverse()

        if len(path) == 1: 
            return []

        return path[1:]

    def heuristic(self, a, b):
        return abs(a[0] - b[0]) + abs(a[1] - b[1])
        # ...

    def is_cell_blocked(self, pos):
        cell_contents = self.model.grid.get_cell_list_contents(pos)
        return any(isinstance(obj, (Car, Moto, Bus)) and obj.crashed for obj in cell_contents)

    def recalculate_path(self):
        if self.destination_hospital:
            self.path = self.calculate_path(self.pos, self.destination_hospital.pos)

    def check_for_crashes(self):
        cell_contents = self.model.grid.get_cell_list_contents(self.pos)
        vehicles_in_cell = [obj for obj in cell_contents if isinstance(obj, (Car, Moto, Bus))]
        if len(vehicles_in_cell) > 1:
            for vehicle in vehicles_in_cell:
                vehicle.crashed = True

    def move(self):
        if self.crashed:
            return

        for _ in range(self.speed):
            if not self.path:
                break

            next_step = self.path[0]

            if self.model.is_red_light(next_step) or self.is_cell_blocked(next_step):
                self.recalculate_path()
                break

            self.model.grid.move_agent(self, next_step)
            self.path.pop(0)
            self.steps_taken += 1

            self.check_for_crashes()

    def step(self):
        if self.crashed:
            return

        if self.has_arrived:
            if self.wait_counter < self.wait_time:
                self.wait_counter += 1
            else:
                self.wait_counter = 0
                self.has_arrived = False
                self.destination_hospital.occupied = False
                self.destination_hospital = self.find_unique_hospital()
                if self.destination_hospital:
                    self.path = self.calculate_path(self.pos, self.destination_hospital.pos)

        else:
            if not self.path:
                self.path = self.calculate_path(self.pos, self.destination_hospital.pos)
                if not self.path:
                    self.destination_hospital = self.find_unique_hospital()
                    if self.destination_hospital:
                        self.path = self.calculate_path(self.pos, self.destination_hospital.pos)
                    return

            self.move()

            if self.pos == self.destination_hospital.pos:
                self.has_arrived = True
                self.destination_hospital.occupied = True

        self.check_for_crashes()

class IntersectionController(Agent):
    def __init__(self, unique_id, model, cycle_time=30):
        super().__init__(unique_id, model)
        self.traffic_lights = []  
        self.cycle_time = cycle_time  
        self.green_duration = 15  
        self.yellow_duration = 10  
        self.red_duration = 5
        self.current_cycle = 0
    
    def calculate_light_state(self, light):
        if self.current_cycle >= light.green_offset and self.current_cycle < light.green_offset + self.green_duration:
            return 'green'
        elif self.current_cycle >= light.green_offset + self.green_duration and self.current_cycle < light.green_offset + self.green_duration + self.yellow_duration:
            return 'yellow'
        else:
            return 'red'
    
    def step(self):
        self.current_cycle = (self.current_cycle + 1) % self.cycle_time
        for light in self.traffic_lights:
            new_state = self.calculate_light_state(light)
            light.change_state(new_state)

class City(Model):
    def __init__(self, width, height):
        self.grid = MultiGrid(width, height, True)
        self.schedule = RandomActivation(self)
        self.parking_agents = []
        self.current_id = 0
        self.running = True
        self.step_count = 0
        self.assigned_parkings = set()
        self.intersection_controller = IntersectionController("ID_Controller", self)
        self.schedule.add(self.intersection_controller)
        self.crash_sites = set()
        self.restaurante_agents = []  
        self.assigned_restaurantes = set()  
        self.bus_stop_agents = [] 
        self.hospital_agents = []

        self.place_hospitals([(9, 21), (19, 6)])
        bus_stop_positions = [(2, 5), (10, 3), (13, 16), (20, 21)] 
        self.place_bus_stops(bus_stop_positions)

        self.allowed_connections = {
            # Borde de mapa
            (23, 1): [(23, 0), (22, 1)], 
            (23, 0): [(23, 1), (22, 0)], 
            (22, 1): [(22, 0), (21, 1)], 
            (22, 0): [(22, 1), (21, 0)], 
            (21, 1): [(21, 0), (20, 1)], 
            (21, 0): [(21, 1), (20, 0)], 
            (20, 1): [(20, 0), (19, 1)], 
            (20, 0): [(19, 0), (20, 1)],
                (19, 1): [(19, 0), (18, 1)],
                (19, 0): [(18, 0), (19, 1)],
                (18, 1): [(18, 0), (17, 1)],
                (18, 0): [(17, 0), (18, 1)],
                (17, 1): [(17, 0), (16, 1)],
                (17, 0): [(16, 0), (17, 1)],
                (16, 1): [(16, 0), (15, 1)],
                (16, 0): [(15, 0), (16, 1)],
                (15, 1): [(15, 0), (14, 1)],
                (15, 0): [(14, 0), (15, 1)],
                (14, 1): [(14, 0), (13, 1)],
                (14, 0): [(13, 0), (14, 1)],
                (13, 1): [(13, 0), (12, 1)],
                (13, 0): [(12, 0), (13, 1)],
                (12, 1): [(12, 0), (11, 1), (12, 2)],
                (12, 0): [(11, 0), (12, 1)],
                (11, 1): [(11, 0), (10, 1), (11, 2)],
                (11, 0): [(10, 0), (11, 1)],
                (10, 1): [(10, 0), (9, 1)],
                (10, 0): [(9, 0), (10, 1)],
                (9, 1): [(9, 0), (8, 1)],
                (9, 0): [(8, 0), (9, 1)],
                (8, 1): [(8, 0), (7, 1)],
                (8, 0): [(7, 0), (8, 1)],
                (7, 1): [(7, 0), (6, 1)],
                (7, 0): [(6, 0), (7, 1)],
                (6, 1): [(6, 0), (5, 1), (6, 2)],
                (6, 0): [(5, 0), (6, 1)],
                (5, 1): [(5, 0), (4, 1)],
                (5, 0): [(4, 0), (5, 1)],
                (4, 1): [(4, 0), (3, 1)],
                (4, 0): [(3, 0), (4, 1)],
                (3, 1): [(3, 0), (2, 1)],
                (3, 0): [(2, 0), (3, 1)],
                (2, 1): [(2, 0), (1, 1)],
                (2, 0): [(1, 0), (2, 1)],
                (1, 1): [(1, 0), (0, 1), (1, 2)],
                (1, 0): [(0, 0), (1, 1)],
                (0, 1): [(0, 0), (0, 2), (1, 1)],
                (0, 0): [(0, 1), (1, 0)], 
                (0, 2): [(1, 2), (0, 3)],
                (0, 3): [(1, 3), (0, 4)],
                (0, 4): [(1, 4), (0, 5)],
                (0, 5): [(1, 5), (0, 6)],
                (0, 6): [(1, 6), (0, 7)],
                (0, 7): [(1, 7), (0, 8)],
                (0, 8): [(1, 8), (0, 9)],
                (0, 9): [(1, 9), (0, 10)],
                (0, 10): [(1, 10), (0, 11)],
                (0, 11): [(1, 11), (0, 12)],
                (0, 12): [(1, 12), (0, 13)],
                (0, 13): [(1, 13), (0, 14)],
                (0, 14): [(1, 14), (0, 15)],
                (0, 15): [(1, 15), (0, 16)],
                (0, 16): [(1, 16), (0, 17)],
                (0, 17): [(1, 17), (0, 18)],
                (0, 18): [(1, 18), (0, 19)],
                (0, 19): [(1, 19), (0, 20)],
                (0, 20): [(1, 20), (0, 21)],
                (0, 21): [(1, 21), (0, 22)],
                (0, 22): [(1, 22), (0, 23)],
                (0, 23): [(1, 23), (0, 22)],
                (1, 2): [(0, 2), (1, 3)],
                (1, 3): [(0, 3), (1, 4)],
                (1, 4): [(0, 4), (1, 5)],
                (1, 5): [(0, 5), (1, 6), (2, 5)],
                (1, 6): [(0, 6), (1, 7)],
                (1, 7): [(0, 7), (1, 8)],
                (1, 8): [(0, 8), (1, 9)],
                (1, 9): [(0, 9), (1, 10), (2, 9)],
                (1, 10): [(0, 10), (1, 11), (2, 10)],
                (1, 11): [(0, 11), (1, 12), (2, 11)],
                (1, 12): [(0, 12), (1, 13)],
                (1, 13): [(0, 13), (1, 14)],
                (1, 14): [(0, 14), (1, 15)],
                (1, 15): [(0, 15), (1, 16)],
                (1, 16): [(0, 16), (1, 17)],
                (1, 17): [(0, 17), (1, 18), (2, 17)],
                (1, 18): [(0, 18), (1, 19)],
                (1, 19): [(0, 19), (1, 20)],
                (1, 20): [(0, 20), (1, 21)],
                (1, 21): [(0, 21), (1, 22)],
                (1, 22): [(0, 22), (1, 23), (2, 22)],
                (1, 23): [(1, 22), (2, 23)], 
                (2, 22): [(3, 22), (2, 23)],
                (3, 22): [(4, 22), (3, 23)],
                (4, 22): [(5, 22), (4, 23)],
                (5, 22): [(6, 22), (5, 23), (5, 21)],
                (6, 22): [(7, 22), (6, 23), (6, 21)],
                (7, 22): [(8, 22), (7, 23)],
                (8, 22): [(9, 22), (8, 23)],
                (9, 22): [(10, 22), (9, 23), (9, 21)],
                (10, 22): [(11, 22), (10, 23)],
                (11, 22): [(12, 22), (11, 23)],
                (12, 22): [(13, 22), (12, 23)],
                (13, 22): [(14, 22), (13, 23)],
                (14, 22): [(15, 22), (14, 23), (14, 21)],
                (15, 22): [(16, 22), (15, 23)],
                (16, 22): [(17, 22), (16, 23)],
                (17, 22): [(18, 22), (17, 23), (17, 21)],
                (18, 22): [(19, 22), (18, 23), (18, 21)],
                (19, 22): [(20, 22), (19, 23)],
                (20, 22): [(21, 22), (20, 23), (20, 21)],
                (21, 22): [(22, 22), (21, 23)],
                (22, 22): [(22, 23), (23, 22), (22, 21)],
                (23, 22): [(23, 23), (22, 22), (23, 21)],
                (2, 23): [(3, 23), (2, 22)],
                (3, 23): [(4, 23), (3, 22)],
                (4, 23): [(5, 23), (4, 22)],
                (5, 23): [(6, 23), (5, 22)],
                (6, 23): [(7, 23), (6, 22)],
                (7, 23): [(8, 23), (7, 22)],
                (8, 23): [(9, 23), (8, 22)],
                (9, 23): [(10, 23), (9, 22)],
                (10, 23): [(11, 23), (10, 22)],
                (11, 23): [(12, 23), (11, 22)],
                (12, 23): [(13, 23), (12, 22)],
                (13, 23): [(14, 23), (13, 22)],
                (14, 23): [(15, 23), (14, 22)],
                (15, 23): [(16, 23), (15, 22)],
                (16, 23): [(17, 23), (16, 22)],
                (17, 23): [(18, 23), (17, 22)],
                (18, 23): [(19, 23), (18, 22)],
                (19, 23): [(20, 23), (19, 22)],
                (20, 23): [(21, 23), (20, 22)],
                (21, 23): [(22, 23), (21, 22)],
                (22, 23): [(23, 23), (22, 22)],
                (23, 23): [(23, 22), (22, 23)], 
                (22, 2): [(23, 2), (22, 1)],
                (22, 3): [(23, 3), (22, 2), (21, 3)],
                (22, 4): [(23, 4), (22, 3)],
                (22, 5): [(23, 5), (22, 4)],
                (22, 6): [(23, 6), (22, 5)],
                (22, 7): [(23, 7), (22, 6)],
                (22, 8): [(23, 8), (22, 7)],
                (22, 9): [(23, 9), (22, 8)],
                (22, 10): [(23, 10), (22, 9)],
                (22, 11): [(23, 11), (22, 10)],
                (22, 12): [(23, 12), (22, 11), (21, 12)],
                (22, 13): [(23, 13), (22, 12), (21, 13)],
                (22, 14): [(23, 14), (22, 13), (21, 14)],
                (22, 15): [(23, 15), (22, 14)],
                (22, 16): [(23, 16), (22, 15)],
                (22, 17): [(23, 17), (22, 16)],
                (22, 18): [(23, 18), (22, 17)],
                (22, 19): [(23, 19), (22, 18), (21, 19)],
                (22, 20): [(23, 20), (22, 19)],
                (22, 21): [(23, 21), (22, 20)],
                (23, 2): [(22, 2), (23, 1)],
                (23, 3): [(22, 3), (23, 2)],
                (23, 4): [(22, 4), (23, 3)],
                (23, 5): [(22, 5), (23, 4)],
                (23, 6): [(22, 6), (23, 5)],
                (23, 7): [(22, 7), (23, 6)],
                (23, 8): [(22, 8), (23, 7)],
                (23, 9): [(22, 9), (23, 8)],
                (23, 10): [(22, 10), (23, 9)],
                (23, 11): [(22, 11), (23, 10)],
                (23, 12): [(22, 12), (23, 11)],
                (23, 13): [(22, 13), (23, 12)],
                (23, 14): [(22, 14), (23, 13)],
                (23, 15): [(22, 15), (23, 14)],
                (23, 16): [(22, 16), (23, 15)],
                (23, 17): [(22, 17), (23, 16)],
                (23, 18): [(22, 18), (23, 17)],
                (23, 19): [(22, 19), (23, 18)],
                (23, 20): [(22, 20), (23, 19)],
                (23, 21): [(22, 21), (23, 20)], 

            # Dentro del mapa
            (5, 21): [(5, 20), (6, 21)], 
            (5, 20): [(5, 19), (6, 20)], 
            (5, 19): [(5, 18), (6, 19)], 
            (5, 18): [(5, 17), (6, 18)], 
            (5, 17): [(5, 16), (6, 17)], 
            (5, 16): [(5, 15), (6, 16)], 
            (5, 15): [(5, 14), (6, 15)], 
            (5, 8): [(5, 7), (6, 8)], 
            (5, 7): [(5, 6), (6, 7)], 
            (5, 6): [(5, 5), (6, 6)], 
            (5, 5): [(5, 4), (6, 5)], 
            (5, 4): [(5, 3), (4, 4), (6, 4)], 
            (5, 3): [(5, 2), (6, 3)], 
            (5, 2): [(5, 1), (6, 2)], 
            (6, 2): [(6, 1), (5, 2)], 
            (6, 3): [(6, 2), (5, 3)], 
            (6, 4): [(6, 3), (5, 4)], 
            (6, 5): [(6, 4), (5, 5)], 
            (6, 6): [(6, 5), (7, 6), (5, 6)], 
            (6, 7): [(6, 6), (5, 7)], 
            (6, 8): [(6, 7), (5, 8)], 
            (6, 15): [(6, 14), (5, 15)], 
            (6, 16): [(6, 15), (5, 16)], 
            (6, 17): [(6, 16), (5, 17)], 
            (6, 18): [(6, 17), (5, 18)], 
            (6, 19): [(6, 18), (5, 19), (7, 19)], 
            (6, 20): [(5, 20), (6, 19)], 
            (6, 21): [(6, 20), (5, 21)], 
            (11, 21): [(11, 22), (12, 21)], 
            (11, 20): [(11, 21), (12, 20)], 
            (11, 19): [(11, 20), (12, 19)], 
            (11, 18): [(11, 19), (12, 18)], 
            (11, 17): [(11, 18), (12, 17)], 
            (11, 16): [(11, 17), (12, 16)], 
            (11, 15): [(11, 16), (12, 15)], 
            (11, 8): [(11, 9), (12, 8)], 
            (11, 7): [(11, 8), (12, 7)], 
            (11, 6): [(11, 7), (12, 6)], 
            (11, 5): [(11, 6), (12, 5)], 
            (11, 4): [(11, 5), (12, 4)], 
            (11, 3): [(11, 4), (10, 3), (12, 3)], 
            (11, 2): [(11, 3), (12, 2)], 
            (12, 2): [(12, 3), (11, 2)], 
            (12, 3): [(12, 4), (11, 3)], 
            (12, 4): [(12, 5), (11, 4)], 
            (12, 5): [(12, 6), (13, 5), (11, 5)], 
            (12, 6): [(12, 7), (11, 6)], 
            (12, 7): [(12, 8), (11, 7)], 
            (12, 8): [(12, 9), (11, 8)], 
            (12, 15): [(12, 16), (11, 15)], 
            (12, 16): [(12, 17), (13, 16), (11, 16)], 
            (12, 17): [(12, 18), (11, 17)], 
            (12, 18): [(12, 19), (11, 18)], 
            (12, 19): [(12, 20), (11, 19)], 
            (12, 20): [(12, 21), (11, 20)], 
            (12, 21): [(12, 22), (11, 21)], 
            (17, 21): [(17, 20), (18, 21)], 
            (17, 20): [(17, 19), (18, 20)], 
            (17, 19): [(17, 18), (18, 19)], 
            (17, 18): [(17, 17), (18, 18)], 
            (17, 17): [(17, 16), (16, 17), (18, 17)], 
            (17, 16): [(17, 15), (18, 16)], 
            (17, 15): [(17, 14), (18, 15)], 
            (17, 8): [(17, 7), (18, 8)], 
            (17, 7): [(17, 6), (16, 7), (18, 7)], 
            (17, 6): [(17, 5), (18, 6)], 
            (17, 5): [(17, 4), (18, 5)], 
            (17, 4): [(17, 3), (18, 4)], 
            (17, 3): [(17, 2), (18, 3)], 
            (17, 2): [(17, 1), (18, 2)], 
            (18, 2): [(18, 1), (17, 2)], 
            (18, 3): [(18, 2), (17, 3)], 
            (18, 4): [(18, 3), (17, 4)], 
            (18, 5): [(18, 4), (17, 5)], 
            (18, 6): [(18, 5), (19, 6), (17, 6)], 
            (18, 7): [(18, 6), (17, 7)], 
            (18, 8): [(18, 7), (17, 8)], 
            (18, 15): [(18, 14), (17, 15)], 
            (18, 16): [(18, 15), (17, 16)], 
            (18, 17): [(18, 16), (17, 17)], 
            (18, 18): [(18, 17), (17, 18)], 
            (18, 19): [(18, 18), (17, 19)], 
            (18, 20): [(18, 19), (17, 20)], 
            (18, 21): [(18, 20), (17, 21)], 
            (21, 14): [(20, 14), (21, 13)], 
            (21, 13): [(21, 14), (20, 13), (21, 12)], 
            (21, 12): [(21, 13), (20, 12)], 
            (20, 14): [(19, 14), (20, 13), (20, 15)], 
            (20, 13): [(20, 14), (19, 13), (20, 12)], 
            (20, 12): [(20, 13), (19, 12)], 
            (19, 14): [(18, 14), (19, 13)], 
            (19, 13): [(19, 14), (18, 13)], 
            (19, 12): [(19, 13)], 
            (18, 14): [(17, 14), (18, 13)], 
            (18, 13): [(18, 14), (17, 13)], 
            (17, 14): [(17, 13), (16, 14)], 
            (17, 13): [(17, 14), (16, 13)], 
            (16, 13): [(16, 14), (15, 13), (16, 12)], 
            (16, 14): [(16, 13), (15, 14)], 
            (16, 12): [(15, 12), (16, 11)], 
            (15, 14): [(15, 13), (14, 14)], 
            (15, 13): [(15, 14), (14, 13), (15, 12)], 
            (15, 12): [(15, 13), (14, 12)], 
            (14, 14): [(13, 14), (14 ,13)], 
            (14, 13): [(14, 14), (13, 13), (14, 12)], 
            (14, 12): [(14, 13), (13, 12)], 
            (13, 14): [(12, 14), (13, 13)], 
            (13, 13): [(13, 14), (12, 13)], 
            (13, 12): [(13, 13)], 
            (12, 14): [(12, 15), (11, 14), (12, 13)], 
            (12, 13): [(12, 14), (11, 13)], 
            (11, 14): [(11, 15), (10, 14), (11, 13)], 
            (11, 13): [(11,14), (10, 13)], 
            (10, 14): [(9, 14), (10, 13)], 
            (10, 13): [(10, 14), (9, 13), (10, 12)], 
            (10, 12): [(9, 12), (10, 11)], 
            (9, 14): [(8, 14), (9, 13)], 
            (9, 13): [(9, 14), (8, 13), (9, 12)], 
            (9, 12): [(9, 13), (8, 12)], 
            (8, 14): [(7, 14), (8, 13)], 
            (8, 13): [(8, 14), (7, 13), (8, 12)], 
            (8, 12): [(8, 13), (7, 12)], 
            (7, 14): [(6, 14), (7, 13)], 
            (7, 13): [(7, 14), (6, 13)], 
            (7, 12): [(7, 13)], 
            (6, 14): [(5, 14), (6, 13)], 
            (6, 13): [(6, 14), (5, 13)], 
            (5, 14): [(5, 13), (4, 14)], 
            (5, 13): [(5, 14), (4, 13)], 
            (4, 14): [(4, 13), (3, 14)], 
            (4, 13): [(4, 14), (3, 13), (4, 12)], 
            (4, 12): [(3, 12), (4, 11)], 
            (3, 14): [(2, 14), (3, 13)], 
            (3, 13): [(3, 14), (2, 13), (3, 12)], 
            (3, 12): [(3, 13), (2, 12)], 
            (2, 14): [(1, 14), (2, 13)], 
            (2, 13): [(2, 14), (1, 13), (2, 12)], 
            (2, 12): [(2, 13), (1, 12)], 
            (2, 11): [(3, 11), (2, 10)], 
            (2, 10): [(2, 11), (3, 10), (2, 9)], 
            (2, 9): [(2, 10), (3, 9)], 
            (3, 11): [(4, 11), (3, 10)], 
            (3, 10): [(3, 11), (4, 10), (3, 9)], 
            (3, 9): [(4, 9), (3, 10)], 
            (4, 11): [(4, 10)], 
            (4, 10): [(5, 10), (4, 9)], 
            (4, 9): [(4, 10), (5, 9)], 
            (5, 9): [(5, 10), (6, 9), (5, 8)], 
            (5, 10): [(6, 10), (5, 9)], 
            (6, 10): [(6, 9), (7, 10)],
            (6, 9): [(6, 10), (7, 9), (6, 8)], 
            (7, 11): [(8, 11), (7, 12)], 
            (7, 10): [(7, 11), (8, 10), (7, 9)], 
            (7, 9): [(7, 10), (8, 9)], 
            (8, 11): [(9, 11), (8, 10)], 
            (8, 10): [(8, 11), (9, 10), (8, 9)],
            (8, 9): [(8, 10), (9, 9)], 
            (9, 11): [(10, 11), (9, 10)], 
            (9, 10): [(9, 11), (10, 10), (9, 9)], 
            (9, 9): [(9, 10), (10, 9)], 
            (10, 11): [(10, 10)], 
            (10, 10): [(11, 10), (10, 9)],
            (10, 9): [(10, 10), (11, 9)], 
            (11, 10): [(12, 10), (11, 9)], 
            (11, 9): [(11, 10), (12, 9)], 
            (12, 10): [(13, 10), (12, 9)], 
            (12, 9): [(12, 10), (13, 9)], 
            (13, 9): [(13, 10), (14, 9)],
            (13, 10): [(13, 9), (14, 10), (13, 11)], 
            (13, 11): [(14, 11), (13, 12)], 
            (14, 9): [(14, 10), (15, 9)], 
            (14, 10): [(14, 11), (15, 10), (14, 9)], 
            (14, 11): [(14, 10), (15, 11)], 
            (15, 9): [(16, 9), (15, 10)],
            (15, 10): [(15, 11), (16, 10), (15, 9)], 
            (15, 11): [(16, 11), (15, 10)], 
            (16, 11): [(16, 10)], 
            (16, 10): [(17, 10), (16, 9)], 
            (16, 9): [(16, 10), (17, 9)], 
            (17, 10): [(18, 10), (17, 9)],
            (17, 9): [(17, 10), (18, 9), (17, 8)], 
            (18, 10): [(19, 10), (18, 9)], 
            (18, 9): [(19, 9), (18, 10), (18, 8)], 
            (19, 11): [(20, 11), (19, 12)], 
            (19, 10): [(19, 11), (20, 10), (19, 9)], 
            (19, 9): [(19, 10), (20, 9)],
            (20, 11): [(21, 11), (20, 10)], 
            (20, 10): [(20, 11), (21, 10), (20, 9)], 
            (20, 9): [(20, 10), (21, 9)], 
            (21, 11): [(22, 11), (21, 10)], 
            (21, 10): [(21, 11), (22, 10), (21, 9)], 
            (21, 9): [(21, 10), (22, 9)],

            # Estacionamientos y sus adyacentes
            (2, 17): [(1, 17)], 
            (7, 19): [(6, 19)], 
            (7, 6): [(6, 6)], 
            (13, 5): [(12, 5)], 
            (16, 7): [(17, 7)], 
            (16, 17): [(17, 17)], 
            (21, 19): [(22, 19)], 
            (20, 15): [(20, 14)], 
            (21, 3): [(22, 3)], 

            # Restaurantes y sus adyacentes
            (14, 21): [(14, 22)], 
            (4, 4): [(5, 4)],

            # Paradas de Cami√≥n y sus adyacentes
            (2, 5): [(1, 5)], 
            (10, 3): [(11, 3)], 
            (13, 16): [(12, 16)], 
            (20, 21): [(20, 22)],

            #Hosiptales y sus adyacentes
            (9, 21): [(9, 22)], 
            (19, 6): [(18, 6)]
        }

        for key, connections in self.allowed_connections.items():
                for connection in connections:
                    if not isinstance(connection, tuple):
                        print(f"Error en la conexi√≥n: {key} a {connection}, que no es una tupla.")

        traffic_lights_data = [
                ((10, 23), 'oeste'), 
                ((10, 22), 'oeste'), 
                ((6, 8), 'sur'), 
                ((5, 8), 'sur'), 
                ((11, 15), 'norte'), 
                ((12, 15), 'norte'), 
                ((21, 22), 'oeste'), 
                ((21, 23), 'oeste'),
                ((17, 8), 'sur'),
                ((18, 8), 'sur'), 
                ((22, 2), 'sur'), 
                ((23, 2), 'sur'), 
                ((0, 21), 'norte'),
                ((1, 21), 'norte'),
                ((2, 1), 'este'),
                ((2, 0), 'este'),  
                ((13, 1), 'este'), 
                ((13, 0), 'este')
            ]

        num_traffic_lights = len(traffic_lights_data)

        available_offset_time = self.intersection_controller.cycle_time - (self.intersection_controller.green_duration + self.intersection_controller.yellow_duration)

        offset_increment = available_offset_time // num_traffic_lights
        
        for i, (pos, orientation) in enumerate(traffic_lights_data):
            green_offset = (i * 5) % self.intersection_controller.cycle_time
            traffic_light = TrafficLightAgent(self.next_id(), self, pos, orientation, green_offset)
            self.grid.place_agent(traffic_light, pos)
            self.schedule.add(traffic_light)
            self.intersection_controller.traffic_lights.append(traffic_light)
        
        self.place_buildings(range(2, 5), [21, 20, 19, 18, 16, 15, 8, 7, 6, 3, 2])
        self.place_buildings(range(3, 5), [17, 5])
        self.place_buildings(range(2, 4), [4])
        self.place_buildings(range(7, 11), [20, 18, 17, 16, 15, 8, 7, 5, 4, 2])
        self.place_buildings(range(7, 9), [21])
        self.place_buildings(range(10, 11), [21])
        self.place_buildings(range(7, 10), [3])
        self.place_buildings(range(8, 11), [19, 6])
        self.place_buildings(range(13, 14), [21])
        self.place_buildings(range(15, 17), [21])
        self.place_buildings(range(13, 17), [20, 19, 18, 15, 8, 6, 4, 3, 2])
        self.place_buildings(range(13, 16), [17, 7])
        self.place_buildings(range(14, 17), [5, 16])
        self.place_buildings(range(19, 22), [20, 18, 17, 16, 8, 7, 5, 4, 2])
        self.place_buildings(range(20, 22), [6])
        self.place_buildings(range(19, 21), [19, 3])
        self.place_buildings(range(19, 20), [21, 15])
        self.place_buildings(range(21, 22), [21, 15])

        self.place_parkings([(2, 17), (7, 19), (7, 6), (16, 17), (13, 5), (16, 7), (21, 19), (20, 15), (21, 3)])
        
        self.place_restaurantes([(14, 21), (4, 4)])
        
        self.place_roundabouts([(5, 12), (6, 12), (5, 11), (6, 11), (11, 12), (11, 11), (12, 12), (12, 11), (17, 12), (17, 11), (18, 12), (18, 11)])

        self.send_car_positions_to_server()
        self.send_moto_positions_to_server()
        self.send_bus_positions_to_server()
        self.send_ev_positions_to_server()
        self.send_initial_traffic_light_positions()
        self.send_traffic_light_states_to_server()

        for restaurante_agent in self.restaurante_agents:
            moto = Moto(self.next_id(), self, restaurante_agent, speed = 3) 
            if moto.destination_restaurante:
                self.grid.place_agent(moto, restaurante_agent.pos)
                self.schedule.add(moto)
            
        for bus_stop_agent in self.bus_stop_agents:
            bus = Bus(self.next_id(), self, bus_stop_agent, speed = 2) 
            if bus.destination_bus_stop: 
                self.grid.place_agent(bus, bus_stop_agent.pos)
                self.schedule.add(bus)

        for parking_agent in self.parking_agents:
            car = Car(self.next_id(), self, parking_agent)
            if car.destination_parking:
                self.grid.place_agent(car, parking_agent.pos)
                self.schedule.add(car)
            
            # Crear y a√±adir los veh√≠culos de emergencia
        for hospital_agent in self.hospital_agents:
                emergency_vehicle = EmergencyVehicle(self.next_id(), self, hospital_agent, speed=1)
                if emergency_vehicle.destination_hospital:
                    self.grid.place_agent(emergency_vehicle, hospital_agent.pos)
                    self.schedule.add(emergency_vehicle)

    def place_buildings(self, x_range, y_positions):
        for x in x_range:
            for y in y_positions:
                building = Building(self.next_id(), self)
                self.grid.place_agent(building, (x, y))
                self.schedule.add(building)

    def place_parkings(self, positions):
        for x, y in positions:
            parking = Parking(self.next_id(), self)
            self.grid.place_agent(parking, (x, y))
            self.schedule.add(parking)
            self.parking_agents.append(parking)
    
    def place_roundabouts(self, positions):
        for x, y in positions:
            roundabout = Roundabout(self.next_id(), self)
            self.grid.place_agent(roundabout, (x, y))
            self.schedule.add(roundabout)
        
    def place_restaurantes(self, positions):
            for x, y in positions:
                restaurante = Restaurante(self.next_id(), self)
                self.grid.place_agent(restaurante, (x, y))
                self.schedule.add(restaurante)
                self.restaurante_agents.append(restaurante)
            
    def place_bus_stops(self, positions):
            for pos in positions:
                bus_stop = BusStop(self.next_id(), self)
                self.grid.place_agent(bus_stop, pos)
                self.schedule.add(bus_stop)
                self.bus_stop_agents.append(bus_stop)
        
    def place_hospitals(self, positions):
            for x, y in positions:
                hospital = Hospital(self.next_id(), self)
                self.grid.place_agent(hospital, (x, y))
                self.schedule.add(hospital)
                self.hospital_agents.append(hospital)
        
    def next_id(self):
        self.current_id += 1
        return self.current_id
        
    def border_positions(self):
            border_positions = []
            for x in range(self.grid.width):
                border_positions.append((x, 0)) 
                border_positions.append((x, self.grid.height - 1))  
            for y in range(1, self.grid.height - 1): 
                border_positions.append((0, y))  
                border_positions.append((self.grid.width - 1, y)) 
            return border_positions
    
    def is_red_light(self, pos):
            cell_contents = self.grid.get_cell_list_contents([pos])
            traffic_lights = [agent for agent in cell_contents if isinstance(agent, TrafficLightAgent)]
            return any(light.state == 'red' for light in traffic_lights)
        
    def is_red_light_or_crash(self, pos):
            cell_contents = self.grid.get_cell_list_contents([pos])
            traffic_lights = [agent for agent in cell_contents if isinstance(agent, TrafficLightAgent)]
            is_red_light = any(light.state == 'red' for light in traffic_lights)

            crashed_cars = [agent for agent in cell_contents if isinstance(agent, Car) and agent.crashed]
            is_crash = len(crashed_cars) > 0

            return is_red_light or is_crash
        
    def add_emergency_vehicle(self):
            start_position, end_position = self.random.sample(self.border_positions(), 2)
            emergency_vehicle = EmergencyVehicle(self.next_id(), self, start_position, end_position)
            self.grid.place_agent(emergency_vehicle, start_position)
            self.schedule.add(emergency_vehicle)

    def total_steps_taken(self):
            return sum(car.steps_taken for car in self.schedule.agents if isinstance(car, Car) and car.has_arrived)

    def send_car_positions_to_server(self):
        positions_data = {f"car_{car_agent.unique_id}": [car_agent.pos[0], car_agent.pos[1]] for car_agent in self.schedule.agents if isinstance(car_agent, Car)}
        requests.post("http://127.0.0.1:5000/update_car_positions", json=positions_data)
    
    def send_moto_positions_to_server(self):
        positions_data = {f"moto_{car_agent.unique_id}": [car_agent.pos[0], car_agent.pos[1]] for car_agent in self.schedule.agents if isinstance(car_agent, Moto)}
        requests.post("http://127.0.0.1:5000/update_moto_positions", json=positions_data)

    def send_bus_positions_to_server(self):
        positions_data = {f"bus_{car_agent.unique_id}": [car_agent.pos[0], car_agent.pos[1]] for car_agent in self.schedule.agents if isinstance(car_agent, Bus)}
        requests.post("http://127.0.0.1:5000/update_bus_positions", json=positions_data)
    
    def send_ev_positions_to_server(self):
        positions_data = {f"ev_{car_agent.unique_id}": [car_agent.pos[0], car_agent.pos[1]] for car_agent in self.schedule.agents if isinstance(car_agent, EmergencyVehicle)}
        requests.post("http://127.0.0.1:5000/update_ev_positions", json=positions_data)
        
    def send_traffic_light_states_to_server(self):
        traffic_light_data = {
            f"traffic_light_{light_agent.unique_id}": {"position": [light_agent.pos[0], light_agent.pos[1]], "state": light_agent.state}
            for light_agent in self.schedule.agents if isinstance(light_agent, TrafficLightAgent)
        }
        requests.post("http://127.0.0.1:5000/update_traffic_light_states", json=traffic_light_data)

    def send_initial_traffic_light_positions(self):
        positions_data = {
            f"traffic_light_{light_agent.unique_id}": [light_agent.pos[0], light_agent.pos[1]]
            for light_agent in self.schedule.agents if isinstance(light_agent, TrafficLightAgent)
        }
        requests.post("http://127.0.0.1:5000/set_traffic_light_positions", json=positions_data)


    def step(self):
        self.schedule.step()
        self.step_count += 1
        if self.step_count >= 1000:
                total_steps = self.total_steps_taken()
                print(f"Total de pasos para que todos los coches lleguen a sus destinos: {total_steps}")
                self.running = False
        self.send_car_positions_to_server()  # A√±adir esta l√≠nea al final de step
        self.send_moto_positions_to_server()
        self.send_bus_positions_to_server()
        self.send_ev_positions_to_server()
        self.send_traffic_light_states_to_server()  # A√±adir esta l√≠nea al final de step


city_model = City(24, 24)
while city_model.running:
  city_model.step()

def agent_portrayal(agent):
    # Veh√≠culos
    if isinstance(agent, Car):
        color = "black" if agent.crashed else "pink"
        portrayal = {"Shape": "circle", "Filled": "true", "Layer": 0, "Color": color, "r": 0.3}
    elif isinstance(agent, Moto):
        color = "black" if agent.crashed else "orange"
        portrayal = {"Shape": "circle", "Filled": "true", "Layer": 0, "Color": color, "r": 0.3}
    elif isinstance(agent, Bus):
        color = "black" if agent.crashed else "cyan"
        portrayal = {"Shape": "circle", "Filled": "true", "Layer": 0, "Color": color, "r": 0.3}
    elif isinstance(agent, EmergencyVehicle):
        color = "black" if agent.crashed else "purple"
        portrayal = {"Shape": "circle", "Filled": "true", "Layer": 0, "Color": color, "r": 0.3}
    
    # Infraestructura de Tr√°fico y Ciudad
    elif isinstance(agent, Restaurante):
        portrayal = {"Shape": "rect", "Filled": "true", "Layer": 0, "Color": "purple", "w": 1, "h": 1}
    elif isinstance(agent, Parking):
        portrayal = {"Shape": "rect", "Filled": "true", "Layer": 0, "Color": "grey", "w": 1, "h": 1}
    elif isinstance(agent, BusStop):
        portrayal = {"Shape": "rect", "Filled": "true", "Layer": 0, "Color": "olive", "w": 1, "h": 1}
    elif isinstance(agent, Roundabout):
        portrayal = {"Shape": "rect", "Filled": "true", "Layer": 0, "Color": "brown", "w": 1, "h": 1}
    elif isinstance(agent, Hospital):
        portrayal = {"Shape": "rect", "Filled": "true", "Layer": 0, "Color": "hotpink", "w": 1, "h": 1}
    elif isinstance(agent, TrafficLightAgent):
        color = "red" if agent.state == 'red' else ("green" if agent.state == 'green' else "yellow")
        portrayal = {"Shape": "circle", "Filled": "true", "Layer": 0, "Color": color, "r": 0.8}
    
    # Edificaciones
    elif isinstance(agent, Building):
        portrayal = {"Shape": "rect", "Filled": "true", "Layer": 0, "Color": "blue", "w": 1, "h": 1}

    return portrayal

grid = CanvasGrid(agent_portrayal, 24, 24, 500, 500)

server = ModularServer(City,
                     [grid],  
                     "City Simulation",
                     {"width": 24, "height": 24}) 

server.port = 8521
server.launch()